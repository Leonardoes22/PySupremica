
from generator_utils import *
from py_supremica.py_supremica import *


###
# Setup
###

fileName = "gen/v3/v3_solo"
moduleComment = "This is an autogenerated termite supervisor, current version - 3"

isMulti = True # Defines if supervisors work with external events
heightMap = [[0,0],[0,1]] # Desired structure map

inTiles = [(1,1),(1,2),(2,1),(2,2)]
outTiles = [(1,1),(1,2),(2,1),(2,2)]

###
# Initialization
##

# HeightMap shape
M = len(heightMap)
N = len(heightMap[0])

enc = GenEnc(M,N)

# Init Module and add comment
mod = Module("Supervisor")
mod.comment = moduleComment

# Init alphabet
ga = Alphabet()
mod.alphabet = ga

# Define base events
ga.newEvent("getBrick")
ga.newEvent("l")
ga.newEvent("r")
ga.newEvent("u")
ga.newEvent("d")

for (i,j) in inTiles:
    ga.newEvent(enc.inEnc(i,j))

for (i,j) in inTiles:
    ga.newEvent(enc.outEnc(i,j))

# Position variables 
mod.addVariable("x","x==0",[0,N+1])
mod.addVariable("y","y==0",[0,M+1])

# heightmap shape constants (#observe)
mod.addConstant("M",M)
mod.addConstant("N",N)

# Initialize height variables, height constants and placing events
placing_events = []
for i in range(1,M+1):
    for j in range(1,N+1):

        # Check if there is need for creation
        if(heightMap[i-1][j-1]>0):

            # Set addTile Events
            event_name = enc.placingEnc(i,j)
            placing_events.append(event_name)
            ga.newEvent(event_name)
            if isMulti:
                ga.newEvent(enc.placingEnc(i,j) + enc.altEnc(), kind="CONTROLLABLE")

            # Set height constants 
            constName = "H"+enc.coordEnc(i,j)
            mod.addConstant(constName, heightMap[i-1][j-1])
        
        # Set height variables
        mod.addVariable(enc.heightEnc(i,j),
                        enc.heightEnc(i,j) + "==0",
                        [0,heightMap[i-1][j-1]+1])


###
# Automata
###

### GR Automaton or G1 ###

gr = Automaton()

# Create states
gr.addState("OUT",initial=True, accepting=True)
gr.addState("IN")

# Add getBrick event
gr.addEdge("OUT","OUT",ga()["getBrick"])

# Add enter grid events
for idx in range(len(inTiles)):
    tile = inTiles[idx]
    i = tile[0]
    j = tile[1]

    gr.addEdge("OUT","IN",ga()[enc.inEnc(i,j)])
    gr.setEdgeActions("OUT", "IN", "y="+str(i)+";x="+str(j),idx)


# Add exit grid events
for idx in range(len(outTiles)):
    tile = outTiles[idx]
    i = tile[0]
    j = tile[1]

    gr.addEdge("IN","OUT",ga()[enc.outEnc(i,j)])
    gr.setEdgeActions("IN", "OUT", "x=0;y=0",idx)
    gr.setEdgeGuard("IN", "OUT", "y=="+ str(i) + "&x=="+str(j),idx)
        

# Add movement in grid events
gr.addEdge("IN","IN",ga()["l"])
gr.setEdgeGuard("IN","IN","x>1")
gr.setEdgeActions("IN","IN","x-=1")

gr.addTransition("IN","IN",ga()["r"])
gr.setEdgeGuard("IN","IN","x<"+str(N),1)
gr.setEdgeActions("IN","IN","x+=1",1)

gr.addTransition("IN","IN",ga()["d"])
gr.setEdgeGuard("IN","IN","y<"+str(M),2)
gr.setEdgeActions("IN","IN","y+=1",2)

gr.addTransition("IN","IN",ga()["u"])
gr.setEdgeGuard("IN","IN","y>1",3)
gr.setEdgeActions("IN","IN","y-=1",3)

mod.automata["GR"] = gr

### GB Automaton or G2 ###

g_b = Automaton()

# Create states
g_b.addState("S0", initial=True,accepting=True)
g_b.addState("S1",accepting=True)

g_b.addEdge("S0","S1", ga()["getBrick"])
g_b.addEdge("S1","S0", [ga()[e] for e in placing_events] )

mod.automata["G_B"] = g_b



### E_M Automaton or G4 ##

e_m = Automaton(kind="SPEC")
e_m.addState("S0",initial = True, accepting =True)

l_guard = ""
u_guard = ""
r_guard = ""
d_guard = ""

for i in range(1,M+1):
    for j in range(1,N+1):

        if(j>1):
            l_guard+= "(x=="+str(j)+" & y=="+str(i)+") & ((-1 <= "+enc.heightEnc(i,j)+"-"+enc.heightEnc(i,j-1)+")&("+enc.heightEnc(i,j)+"-"+enc.heightEnc(i,j-1)+" <= 1))|"
        if(i>1):
            u_guard+= "(x=="+str(j)+" & y=="+str(i)+") & ((-1 <= "+enc.heightEnc(i,j)+"-"+enc.heightEnc(i-1,j)+")&("+enc.heightEnc(i,j)+"-"+enc.heightEnc(i-1,j)+" <= 1))|"
        if(j<N):
            r_guard+= "(x=="+str(j)+" & y=="+str(i)+") & ((-1 <= "+enc.heightEnc(i,j)+"-"+enc.heightEnc(i,j+1)+")&("+enc.heightEnc(i,j)+"-"+enc.heightEnc(i,j+1)+" <= 1))|"
        if(i<M):
            d_guard+= "(x=="+str(j)+" & y=="+str(i)+") & ((-1 <= "+enc.heightEnc(i,j)+"-"+enc.heightEnc(i+1,j)+")&("+enc.heightEnc(i,j)+"-"+enc.heightEnc(i+1,j)+" <= 1))|"

if(N>1):
    e_m.addEdge("S0","S0",ga()["r"])
    e_m.addEdge("S0","S0",ga()["l"])

    e_m.setEdgeGuard("S0","S0",r_guard,0)
    e_m.setEdgeGuard("S0","S0",l_guard,1)
if(M>1):
    fix = 2 if N>1 else 0
    e_m.addEdge("S0","S0",ga()["u"])
    e_m.addEdge("S0","S0",ga()["d"])

    e_m.setEdgeGuard("S0","S0",u_guard,0+fix)
    e_m.setEdgeGuard("S0","S0",d_guard,1+fix)

mod.automata["E_M"] = e_m

### G5 ###

G5 = Automaton(kind="SPEC")
G5.addState("S0",initial = True, accepting =True)

borderTiles = inTiles+outTiles

for idx in range(len(borderTiles)):

    i = borderTiles[idx][0]
    j = borderTiles[idx][1]

    if idx < len(inTiles):
        G5.addEdge("S0", "S0", ga()[enc.inEnc(i, j)])
    else:
        G5.addEdge("S0", "S0", ga()[enc.outEnc(i, j)])

    step_guard = enc.heightEnc(i,j) +"<= 1"
    G5.setEdgeGuard("S0", "S0", step_guard,idx)


mod.automata["G5"] = G5

###
# Variable Automata
###

### Gadd_ix Automaton or G3 ###

for i in range(1,M+1):
    if(sum(heightMap[i-1]) > 0):
        ### Gadd_ix Automaton or G3 ###
        gadd_ix = Automaton()
        gadd_ix.addState("L1", initial=True, accepting=True)

        ### Gadd_ix Automaton (for external events) or G3 ###
        if isMulti:
            gadd_ix_r2 = Automaton()
            gadd_ix_r2.addState("L1", initial=True, accepting=True)

        count = 0
        for j in range(1,N+1):
            if heightMap[i-1][j-1] > 0:

                ### Populate G3's ###
                gadd_ix.addEdge("L1","L1",ga()[enc.placingEnc(i,j)])
                gadd_ix.setEdgeActions("L1","L1",enc.heightEnc(i,j)+"+=1",count)

                guard = ""
                for n in enc.getNeighbors(i, j):
                    guard += "(x=="+str(n[1])+" & y=="+str(n[0])+")|"

                if ((i,j) in inTiles + outTiles):
                    guard += "(x==0 & y==0)"

                gadd_ix.setEdgeGuard("L1","L1",guard,count)

                if isMulti:
                    gadd_ix_r2.addEdge("L1","L1",ga()[enc.placingEnc(i,j)+enc.altEnc()])
                    gadd_ix_r2.setEdgeActions("L1","L1",enc.heightEnc(i,j)+"+=1",count)
            
                ### E_aij Automaton or G6 ###
                e_aij = Automaton(kind="SPEC")
                e_aij.addState("S0", initial=True, accepting=True)
                e_aij.addEdge("S0","S0",ga()[enc.placingEnc(i,j)])
                e_aij.addEventToEdge("S0","S0",ga()[enc.placingEnc(i,j)+"_r2"])

                guard = ""
                for n in enc.getNeighbors(i, j):
                    guard += "(x=="+str(n[1])+" & y=="+str(n[0])+") & ("+enc.heightEnc(i,j)+"=="+enc.heightEnc(n[0],n[1])+")|"

                if ((i,j) in inTiles + outTiles):
                    guard += "(x==0 & y==0) & ("+enc.heightEnc(i,j)+"==0)|"

                e_aij.setEdgeGuard("S0","S0",guard)

                mod.automata["E_a"+enc.coordEnc(i,j)] = e_aij

                ### E_Hij Automaton or G8 ###
                e_hij = Automaton(kind="SPEC")
                e_hij.addState("B0", initial=True)
                e_hij.addState("B1", accepting=True)

                e_hij.addEdge("B0","B0",ga()[enc.placingEnc(i,j)])
                e_hij.addEventToEdge("B0","B0", ga()[enc.placingEnc(i,j)+"_r2"])
                e_hij.setEdgeGuard("B0","B0",enc.heightEnc(i,j)+"<"+"H"+enc.coordEnc(i,j)+"-1")

                e_hij.addEdge("B0","B1",ga()[enc.placingEnc(i,j)])
                e_hij.addEventToEdge("B0","B1", ga()[enc.placingEnc(i,j)+"_r2"])
                e_hij.setEdgeGuard("B0","B1",enc.heightEnc(i,j)+"=="+"H"+enc.coordEnc(i,j)+"-1")

                mod.automata["E_H"+enc.coordEnc(i,j)] = e_hij

                count += 1


         ### Finish G3's ###
        mod.automata["GAdd_"+str(i)+"X"] = gadd_ix
        if isMulti:
            mod.automata["GAdd_"+str(i)+"X"+enc.altEnc()] = gadd_ix_r2




for i in range(1,M+1):
    for j in range(1,N+1):

        ### E_Uij Automaton or G7 ###
        n_i = (i-1,j) in enc.getNeighbors(i, j) and (i+1,j) in enc.getNeighbors(i, j)
        n_j = (i,j-1) in enc.getNeighbors(i, j) and (i,j+1) in enc.getNeighbors(i, j)

        if( n_i or n_j):
            e_uij = Automaton(kind="SPEC")
            e_uij.addState("S0",initial=True, accepting=True)
            e_uij.addEdge("S0","S0",ga()[enc.placingEnc(i,j)])
            e_uij.addEventToEdge("S0","S0",ga()[enc.placingEnc(i,j)+"_r2"])
            guard = ""
            if(n_i):
                guard += "("+enc.heightEnc(i,j)+" >= "+enc.heightEnc(i-1,j)+"  |  "+enc.heightEnc(i,j)+" >= "+enc.heightEnc(i+1,j)+")&"
            if(n_j):
                guard += "("+enc.heightEnc(i,j)+" >= "+enc.heightEnc(i,j-1)+"  |  "+enc.heightEnc(i,j)+" >= "+enc.heightEnc(i,j+1)+")"
            e_uij.setEdgeGuard("S0","S0",guard)

            mod.automata["E_U"+enc.coordEnc(i,j)] = e_uij

        

#  Generate
mod.toWMOD(fileName)